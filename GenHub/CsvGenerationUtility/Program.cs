

using System.Security.Cryptography;
using CsvHelper;
using CsvHelper.Configuration;
using GenHub.Core.Models.Content;
using GenHub.Core.Models.Enums;
using GenHub.Core.Models.GameInstallations;
using GenHub.Core.Models.Results;
using GenHub.Windows.GameInstallations;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Console;
using Newtonsoft.Json;

namespace CsvGenerationUtility;
// StyleCop suppressions for utility classes in single file
// <auto-generated/>
#pragma warning disable SA1402 // File may only contain a single type
#pragma warning disable SA1516 // Elements should be separated by blank line

/// <summary>
/// CSV Generation Utility for creating authoritative CSV files from game installations.
/// </summary>
internal static class Program
{
    /// <summary>
    /// Main entry point for the CSV Generation Utility.
    /// </summary>
    /// <param name="args">Command line arguments.</param>
    /// <returns>A task representing the asynchronous operation.</returns>
    private static async Task Main(string[] args)
    {
        var configuration = BuildConfiguration();
        var logger = CreateLogger();

        try
        {
            logger.LogInformation("Starting CSV Generation Utility");

            var generator = new CsvGenerator(configuration, logger);
            await generator.GenerateAllCsvFilesAsync();

            logger.LogInformation("CSV Generation Utility completed successfully");
        }
        catch (Exception ex)
        {
            logger.LogError(ex, "CSV Generation Utility failed");
            Environment.Exit(1);
        }
    }

    private static IConfiguration BuildConfiguration()
    {
        return new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.json", optional: true)
            .Build();
    }

    private static ILogger CreateLogger()
    {
        using var loggerFactory = LoggerFactory.Create(builder =>
        {
            builder.AddConsole();
            builder.SetMinimumLevel(LogLevel.Information);
        });

        return loggerFactory.CreateLogger("CsvGenerator");
    }
}

/// <summary>
/// Generates CSV files from game installations.
/// </summary>
internal class CsvGenerator
{
    private readonly IConfiguration configuration;
    private readonly ILogger logger;

    /// <summary>
    /// Initializes a new instance of the <see cref="CsvGenerator"/> class.
    /// </summary>
    /// <param name="configuration">The configuration.</param>
    /// <param name="logger">The logger.</param>
    public CsvGenerator(IConfiguration configuration, ILogger logger)
    {
        this.configuration = configuration ?? throw new ArgumentNullException(nameof(configuration));
        this.logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Generates CSV files for all supported games.
    /// </summary>
    /// <returns>A task representing the asynchronous operation.</returns>
    public async Task GenerateAllCsvFilesAsync()
    {
        var games = new[]
        {
                (GameType.Generals, "1.08", "Generals-1.08.csv"),
                (GameType.ZeroHour, "1.04", "ZeroHour-1.04.csv"),
            };

        foreach (var (gameType, version, csvFileName) in games)
        {
            await this.GenerateCsvForGameAsync(gameType, version, csvFileName);
        }

        await this.UpdateIndexJsonAsync();
    }

    private async Task GenerateCsvForGameAsync(GameType gameType, string version, string csvFileName)
    {
        this.logger.LogInformation("Generating CSV for {GameType} {Version}", gameType, version);

        var installationPath = this.GetInstallationPath(gameType);
        if (string.IsNullOrEmpty(installationPath) || !Directory.Exists(installationPath))
        {
            this.logger.LogWarning("Installation path not found for {GameType}: {Path}", gameType, installationPath);
            return;
        }

        var csvEntries = await this.ScanInstallationAsync(installationPath, gameType);
        var csvPath = Path.Combine(this.GetRegistryDirectory(), csvFileName);

        await this.WriteCsvFileAsync(csvEntries, csvPath);
        this.logger.LogInformation("Generated CSV file: {Path} with {Count} entries", csvPath, csvEntries.Count);
    }

    private string? GetInstallationPath(GameType gameType)
    {
        this.logger.LogInformation("Detecting installation path for {GameType}", gameType);

        try
        {
            // Use the Windows installation detector to find actual installations
            var detectorLogger = LoggerFactory.Create(builder =>
            {
                builder.AddConsole();
                builder.SetMinimumLevel(LogLevel.Information);
            }).CreateLogger<WindowsInstallationDetector>();

            var detector = new WindowsInstallationDetector(detectorLogger);
            var detectionResult = detector.DetectInstallationsAsync().GetAwaiter().GetResult();

            if (!detectionResult.Success || !detectionResult.Items.Any())
            {
                this.logger.LogWarning("Installation detection failed: {Error}", detectionResult.FirstError);
                return null;
            }

            // Find the installation that matches the requested game type
            var matchingInstallation = detectionResult.Items.FirstOrDefault(install =>
                (gameType == GameType.Generals && install.HasGenerals) ||
                (gameType == GameType.ZeroHour && install.HasZeroHour));

            if (matchingInstallation == null)
            {
                this.logger.LogWarning("No installation found for {GameType}. Available installations:", gameType);
                foreach (var install in detectionResult.Items)
                {
                    this.logger.LogWarning("  - {Type}: Generals={HasGenerals} ({GeneralsPath}), ZeroHour={HasZeroHour} ({ZeroHourPath})", install.InstallationType, install.HasGenerals, install.GeneralsPath, install.HasZeroHour, install.ZeroHourPath);
                }
                return null;
            }

            var installationPath = gameType == GameType.Generals
                ? matchingInstallation.GeneralsPath
                : matchingInstallation.ZeroHourPath;

            this.logger.LogInformation("Found installation path for {GameType}: {Path}", gameType, installationPath);
            return installationPath;
        }
        catch (Exception ex)
        {
            this.logger.LogError(ex, "Error detecting installation path for {GameType}", gameType);
            return null;
        }
    }

    private async Task<List<CsvCatalogEntry>> ScanInstallationAsync(string installationPath, GameType gameType)
    {
        var entries = new List<CsvCatalogEntry>();
        var language = this.DetectLanguage(installationPath);

        var files = Directory.GetFiles(installationPath, "*", SearchOption.AllDirectories);
        var totalFiles = files.Length;

        this.logger.LogInformation("Scanning {Count} files in {Path}", totalFiles, installationPath);

        for (var i = 0; i < files.Length; i++)
        {
            var file = files[i];
            if (i % 100 == 0)
            {
                this.logger.LogInformation("Processed {Current}/{Total} files", i, totalFiles);
            }

            try
            {
                var entry = await this.CreateCsvEntryAsync(file, installationPath, gameType, language);
                if (entry != null)
                {
                    entries.Add(entry);
                }
            }
            catch (Exception ex)
            {
                this.logger.LogWarning(ex, "Failed to process file: {Path}", file);
            }
        }

        return entries.OrderBy(e => e.RelativePath).ToList();
    }

    private async Task<CsvCatalogEntry?> CreateCsvEntryAsync(string filePath, string installationPath, GameType gameType, string language)
    {
        var relativePath = Path.GetRelativePath(installationPath, filePath).Replace('\\', '/');
        var fileInfo = new FileInfo(filePath);

        if (fileInfo.Length == 0)
        {
            return null; // Skip empty files
        }

        var (md5, sha256) = await this.CalculateHashesAsync(filePath);

        return new CsvCatalogEntry
        {
            RelativePath = relativePath,
            Size = fileInfo.Length,
            Md5 = md5,
            Sha256 = sha256,
            GameType = gameType.ToString(),
            Language = language,
            IsRequired = this.IsRequiredFile(relativePath),
            Metadata = this.GetFileMetadata(relativePath),
        };
    }

    private async Task<(string Md5, string Sha256)> CalculateHashesAsync(string filePath)
    {
        using var stream = File.OpenRead(filePath);
        using var md5 = MD5.Create();
        using var sha256 = SHA256.Create();

        var buffer = new byte[8192];
        int bytesRead;

        while ((bytesRead = await stream.ReadAsync(buffer)) > 0)
        {
            md5.TransformBlock(buffer, 0, bytesRead, null, 0);
            sha256.TransformBlock(buffer, 0, bytesRead, null, 0);
        }

        md5.TransformFinalBlock(Array.Empty<byte>(), 0, 0);
        sha256.TransformFinalBlock(Array.Empty<byte>(), 0, 0);

        return (
            BitConverter.ToString(md5.Hash!).Replace("-", string.Empty).ToLowerInvariant(),
            BitConverter.ToString(sha256.Hash!).Replace("-", string.Empty).ToLowerInvariant());
    }

    private string DetectLanguage(string installationPath)
    {
        // Check for language-specific files
        var languageFiles = new[]
        {
                ("Data/Lang/English/game.str", "EN"),
                ("Data/Lang/German/game.str", "DE"),
                ("Data/Lang/French/game.str", "FR"),
                ("Data/Lang/Spanish/game.str", "ES"),
                ("Data/Lang/Italian/game.str", "IT"),
                ("Data/Lang/Korean/game.str", "KO"),
                ("Data/Lang/Polish/game.str", "PL"),
                ("Data/Lang/Portuguese/game.str", "PT-BR"),
                ("Data/Lang/Chinese_S/game.str", "ZH-CN"),
                ("Data/Lang/Chinese_T/game.str", "ZH-TW"),
            };

        foreach (var (file, lang) in languageFiles)
        {
            if (File.Exists(Path.Combine(installationPath, file)))
            {
                return lang;
            }
        }

        return "EN"; // Default to English
    }

    private bool IsRequiredFile(string relativePath)
    {
        // Core game files that are always required
        var requiredFiles = new[]
        {
                "game.exe",
                "game.dat",
                "Data/INI/GameData.ini",
                "Data/INI/English.ini",
                "Data/Lang/English/game.str",
            };

        return requiredFiles.Any(rf => relativePath.EndsWith(rf, StringComparison.OrdinalIgnoreCase));
    }

    private string GetFileMetadata(string relativePath)
    {
        var metadata = new Dictionary<string, string>();

        if (relativePath.StartsWith("Data/INI/", StringComparison.OrdinalIgnoreCase))
        {
            metadata["category"] = "config";
        }
        else if (relativePath.StartsWith("Data/Lang/", StringComparison.OrdinalIgnoreCase))
        {
            metadata["category"] = "language";
        }
        else if (relativePath.StartsWith("Data/Maps/", StringComparison.OrdinalIgnoreCase))
        {
            metadata["category"] = "maps";
        }
        else if (relativePath.EndsWith(".wav", StringComparison.OrdinalIgnoreCase) ||
                 relativePath.EndsWith(".mp3", StringComparison.OrdinalIgnoreCase))
        {
            metadata["category"] = "audio";
        }
        else if (relativePath.EndsWith(".w3d", StringComparison.OrdinalIgnoreCase) ||
                 relativePath.EndsWith(".dds", StringComparison.OrdinalIgnoreCase))
        {
            metadata["category"] = "graphics";
        }
        else
        {
            metadata["category"] = "other";
        }

        return JsonConvert.SerializeObject(metadata);
    }

    private async Task WriteCsvFileAsync(List<CsvCatalogEntry> entries, string csvPath)
    {
        var config = new CsvConfiguration(System.Globalization.CultureInfo.InvariantCulture)
        {
            HasHeaderRecord = true,
        };

        await using var writer = new StreamWriter(csvPath);
        await using var csv = new CsvWriter(writer, config);

        await csv.WriteRecordsAsync(entries);
    }

    private async Task UpdateIndexJsonAsync()
    {
        var registryDir = this.GetRegistryDirectory();
        var indexPath = Path.Combine(registryDir, "index.json");

        var registries = new List<CsvRegistryEntry>();

        foreach (var csvFile in Directory.GetFiles(registryDir, "*.csv"))
        {
            var fileName = Path.GetFileName(csvFile);
            var gameType = fileName.Contains("Generals") ? GameType.Generals : GameType.ZeroHour;
            var version = fileName.Contains("1.08") ? "1.08" : "1.04";

            var entries = this.ReadCsvEntriesAsync(csvFile);
            var (md5, sha256) = await this.CalculateHashesAsync(csvFile);

            registries.Add(new CsvRegistryEntry
            {
                Id = $"{gameType.ToString().ToLowerInvariant()}-{version}",
                GameType = gameType.ToString(),
                Version = version,
                Url = $"https://raw.githubusercontent.com/Community-Outpost/GenHub/main/docs/GameInstallationFilesRegistry/{fileName}",
                FileCount = entries.Count,
                TotalSizeBytes = entries.Sum(e => e.Size),
                Languages = entries.Select(e => e.Language).Distinct().OrderBy(l => l).ToList(),
                Checksum = new Checksum { Md5 = md5, Sha256 = sha256 },
                GeneratedAt = DateTime.UtcNow.ToString("O"),
                GeneratorVersion = "1.0.0",
                IsActive = true,
            });
        }

        var index = new CsvRegistryIndex
        {
            Version = "1.0.0",
            LastUpdated = DateTime.UtcNow.ToString("O"),
            Description = "CSV registry metadata for Command & Conquer Generals and Zero Hour installation validation",
            Registries = registries,
        };

        var json = JsonConvert.SerializeObject(index, Formatting.Indented);
        await File.WriteAllTextAsync(indexPath, json);

        this.logger.LogInformation("Updated index.json with {Count} registries", registries.Count);
    }

    private List<CsvCatalogEntry> ReadCsvEntriesAsync(string csvPath)
    {
        var config = new CsvConfiguration(System.Globalization.CultureInfo.InvariantCulture)
        {
            HasHeaderRecord = true,
        };

        using var reader = new StreamReader(csvPath);
        using var csv = new CsvReader(reader, config);

        var records = csv.GetRecords<CsvCatalogEntry>();
        return records.ToList();
    }

    private string GetRegistryDirectory()
    {
        return Path.Combine(Directory.GetCurrentDirectory(), "..", "..", "docs", "GameInstallationFilesRegistry");
    }
}

/// <summary>
/// Represents a checksum with MD5 and SHA256 hashes.
/// </summary>
internal class Checksum
{
    /// <summary>
    /// Gets or sets the MD5 hash.
    /// </summary>
    public string? Md5 { get; set; }

    /// <summary>
    /// Gets or sets the SHA256 hash.
    /// </summary>
    public string? Sha256 { get; set; }
}

/// <summary>
/// Represents an entry in the CSV registry index.
/// </summary>
internal class CsvRegistryEntry
{
    /// <summary>
    /// Gets or sets the registry ID.
    /// </summary>
    public string? Id { get; set; }

    /// <summary>
    /// Gets or sets the game type.
    /// </summary>
    public string? GameType { get; set; }

    /// <summary>
    /// Gets or sets the game version.
    /// </summary>
    public string? Version { get; set; }

    /// <summary>
    /// Gets or sets the CSV file URL.
    /// </summary>
    public string? Url { get; set; }

    /// <summary>
    /// Gets or sets the number of files in the CSV.
    /// </summary>
    public int FileCount { get; set; }

    /// <summary>
    /// Gets or sets the total size of all files in bytes.
    /// </summary>
    public long TotalSizeBytes { get; set; }

    /// <summary>
    /// Gets or sets the list of supported languages.
    /// </summary>
    public List<string>? Languages { get; set; }

    /// <summary>
    /// Gets or sets the checksum information.
    /// </summary>
    public Checksum? Checksum { get; set; }

    /// <summary>
    /// Gets or sets the generation timestamp.
    /// </summary>
    public string? GeneratedAt { get; set; }

    /// <summary>
    /// Gets or sets the generator version.
    /// </summary>
    public string? GeneratorVersion { get; set; }

    /// <summary>
    /// Gets or sets a value indicating whether this registry is active.
    /// </summary>
    public bool IsActive { get; set; }
}

/// <summary>
/// Represents the CSV registry index.
/// </summary>
internal class CsvRegistryIndex
{
    /// <summary>
    /// Gets or sets the index version.
    /// </summary>
    public string? Version { get; set; }

    /// <summary>
    /// Gets or sets the last updated timestamp.
    /// </summary>
    public string? LastUpdated { get; set; }

    /// <summary>
    /// Gets or sets the index description.
    /// </summary>
    public string? Description { get; set; }

    /// <summary>
    /// Gets or sets the list of registry entries.
    /// </summary>
    public List<CsvRegistryEntry>? Registries { get; set; }
}
